---
layout: post
title: "System call internal"
date:  2018-10-02 19:02:00 +0800
---

# 系统调用过程
OS系统调用完成了内核和用户进程的隔绝，同时系统调用也将部分内核功能暴露给用户，是用户进程与内核交互的接口。

系统调用是编程过程中不可避免的，无论是文件交换，io操作，同步处理都会用到。这里想简要说明一下系统调用的基本过程。

## 几个问题
首先是几个有关系统调用的问题，也主要是我在学习过程中遇到的一些问题
1. 中断和异常处理以及系统调用的区别
2. 用户程序是如何陷入系统调用，在系统调用执行过程中内核和用户程序如何通信
3. 内核在哪里执行系统调用，是在调用进程的地址空间？

下面我会尝试回答下上面的几个问题。回答不一定正确，只是说一下我的理解。在这之前推荐一个课程：MIT 操作系统课[1]。这个一直没有完全做完，但里面的内容确实十分有意思，可以学到操作系统的不少东西。

### 系统调用与中断和异常

1. 系统调用：用户进程调用系统调用提供的接口而使处理器陷入内核模式
2. 异常：用户程序进行非法操作如处理错误、访问非法地址等
3. 中断： 由外部硬件产生的中断

所有这些都有内核来负责处理完成。虽然系统调用、异常和中断产生的原因不同，但操作系统处理其的方式大多是相同的。

对于x86的处理器来说，这些操作都会产生一个`int`指令。同时处理器终止正常的指令执行操作，还是进入中断处理程序。


### 关于系统调用的执行过程
这里具体说明一下系统调用的整个过程。系统调用实际就是从用户态转到内核态的一个操作。要完成这一操作需要考虑这几个问题：

1. 安全性和隔绝性，我们必须保护内核的安全并防止用户进程破坏内核
2. 如何正确完成用户到内核，内核到用户态的切换

#### xv6系统调用执行过程
xv6[2]是MIT的一个教学操作系统，大约有1万行源码。这里简要说明一下该系统的系统调用过程。

x86处理器的权限分为4级，也就是我们常见的`ring0-ring3`。其中内核通常运行在`ring0`级别而用户进程运行在`ring3`级别。这一级别存储在`%cs`寄存器中。

同时每个中断都有一个中断处理函数入口地址，这一地址存储在IDT表中。

`int`指令将会执行如下操作：
1. 从IDT中获取合适的中断处理的IDT entry
2. 检查`%cs`中的level是否<= IDT entry中存储的level。如果不是则返回错误代码13
3. 将ss，和esp存储到处理器其他寄存器中 （只在%cs level为 > 目标level时进行）
4. load target %ss和%esp ---- 此时进入内核栈空间
5. push %ss，%esp（第3步进行是使用）
6. push %eflag
7. push %cs -- code segment
8. push %eip
9. clean IF bit in EFLAG -- 禁止嵌套中断，只在该中断是硬件中断的时候
10. load %cs, %eip from IDT entry

图1显示了`int`指令后，kernel stack的调用栈：

![System call Pic](/media/image/syscall1.PNG "system call kernel栈空间的分配")

在完成上面指令后，处理器即从用户态转到内核态，接着就可以执行系统调用的后续操作。
1. 将error code 和 interrupt number继续压栈。同时将通用寄存器压栈。之后内核栈将变为下图所示。此时已经建立好应有的栈帧结构，该结构与结构体`struct trapframe`相对应，将传给后续的函数使用。
![System call 2 Pic](/media/image/syscall2.PNG "system call kernel栈空间的分配2")
2. 之后函数将调用`trap(struct trapframe *tf)`函数，该函数负责调用合适的中断处理程序。由于我们目前只关心系统调用，所以这里只看系统调用的部分。`trap`函数对调用syscall的程序进行简单校验，将当前进程的`trapframe`设为参数传入的值，然后调用`syscall()`函数处理。
3. `syscall()`函数需要知道(1) 具体的系统调用， (2) 完成该系统调用需要的参数。来完成后续的操作。具体的系统调用可以从`trapframe`结构中的`%eax`中获得；而具体的参数由于在保存栈帧的时候保存了user的esp，所以根据系统调用的参数类型，加上相应偏移就可推断出参数的具体地址，进而相应变量中。
4. 在内核完成系统调用函数和参数确定后即调用真正的处理函数。完成之后将错误码放如`tf->exa`中。在调用返回后将当作系统调用的返回值
#### Linux 系统调用过程
Linux 系统调用过程和xv6基本一样，但不同的有：
1. Linux 系统调用的参数传递是通过寄存器传递，特定寄存器传递特定的参数
2. Linux 系统调用有更加严格的参数检测，比如检查用户传入的地址是否为用户空间地址，从而防止用户破坏内核结构。
3. Linux 系统调用有可能会出现异常，比如`page fault`。这时候就需要一定的机制来判断这个错误是由内核引起还是由用户引起（由于操作系统的内存分配通常采用`lazy alloc`，所以当用户传入一个未分配的地址时并不代表一个错误）。这时，Linux采用记录所访问的用户地址的方式来判断异常产生的原因。[3]


## References
[1] https://pdos.csail.mit.edu/6.828/2018/schedule.html

[2] https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf

[3] http://courses.cms.caltech.edu/cs124/lectures/CS124Lec14.pdf